#!/bin/bash
# vendor-sources - Wrapper script for vendoring source archives
#
# This script wraps the BXL command and handles the actual file operations
# (downloading, manifest management) that BXL cannot perform directly.
#
# All vendored sources are stored in a centralized vendor/ directory
# with a single MANIFEST.json tracking all sources.
#
# Usage:
#   ./tools/vendor-sources --target //packages/linux/core:bash
#   ./tools/vendor-sources --target //packages/linux/core:bash --dry-run
#   ./tools/vendor-sources --verify
#   ./tools/vendor-sources --clean
#   ./tools/vendor-sources --list

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Find the Buck project root (where .buckroot or .buckconfig is)
# Skip the local config if we're inside a parent repo
BUCK_ROOT="$REPO_ROOT"
search_dir="$(dirname "$REPO_ROOT")"
while [[ "$search_dir" != "/" ]]; do
    if [[ -f "$search_dir/.buckroot" || -f "$search_dir/.buckconfig" ]]; then
        BUCK_ROOT="$search_dir"
        break
    fi
    search_dir="$(dirname "$search_dir")"
done

# Convert arguments for BXL CLI format
ARGS=()
for arg in "$@"; do
    if [[ "$arg" == --dry-run ]]; then
        ARGS+=("--dry_run" "true")
    elif [[ "$arg" == --verify ]]; then
        ARGS+=("--verify" "true")
    elif [[ "$arg" == --clean ]]; then
        ARGS+=("--clean" "true")
    elif [[ "$arg" == --list ]]; then
        ARGS+=("--list" "true")
    else
        ARGS+=("$arg")
    fi
done

# Determine if running in a parent repo context (buckos cell exists)
CELL_PREFIX=""
if (cd "$BUCK_ROOT" && buck2 audit cell 2>/dev/null) | grep -q "^buckos:"; then
    CELL_PREFIX="buckos"
fi

# Convert target paths to use cell prefix if needed
if [[ -n "$CELL_PREFIX" ]]; then
    PREFIXED_ARGS=()
    for arg in "${ARGS[@]}"; do
        if [[ "$arg" == "--target" ]]; then
            PREFIXED_ARGS+=("$arg")
        elif [[ "$arg" == //* && "${PREFIXED_ARGS[-1]:-}" == "--target" ]]; then
            # Convert //path to buckos//path
            PREFIXED_ARGS+=("${CELL_PREFIX}${arg}")
        else
            PREFIXED_ARGS+=("$arg")
        fi
    done
    ARGS=("${PREFIXED_ARGS[@]}")
    BXL_PATH="${CELL_PREFIX}//defs:vendor_sources.bxl:vendor_sources"
else
    BXL_PATH="//defs:vendor_sources.bxl:vendor_sources"
fi

# Run the BXL script and capture output (from Buck root)
BXL_OUTPUT=$(cd "$BUCK_ROOT" && buck2 bxl "$BXL_PATH" -- "${ARGS[@]}" 2>&1)

# Parse the BXL output (include digits for SOURCE_0_*, etc.)
eval "$(echo "$BXL_OUTPUT" | grep -E '^[A-Z][A-Z0-9_]*=' | head -200)"

# Handle different actions
case "$VENDOR_ACTION" in
    clean)
        echo "Cleaning vendored sources..."
        if [[ -n "$VENDOR_DIR" && -d "$REPO_ROOT/$VENDOR_DIR" ]]; then
            echo "  Removing: $VENDOR_DIR/"
            rm -rf "$REPO_ROOT/$VENDOR_DIR"
        fi
        echo "Done."
        ;;

    list)
        echo "Vendored sources in $VENDOR_DIR/:"
        MANIFEST="$REPO_ROOT/$VENDOR_DIR/MANIFEST.json"
        if [[ -f "$MANIFEST" ]] && command -v jq &> /dev/null; then
            jq -r '.sources[] | "  \(.filename) (\(.target))"' "$MANIFEST" 2>/dev/null
        elif [[ -d "$REPO_ROOT/$VENDOR_DIR" ]]; then
            # List files if no manifest
            for f in "$REPO_ROOT/$VENDOR_DIR"/*; do
                if [[ -f "$f" && "$(basename "$f")" != "MANIFEST.json" ]]; then
                    echo "  $(basename "$f")"
                fi
            done
        else
            echo "  (no vendored sources)"
        fi
        ;;

    verify)
        echo "Verifying vendored sources in $VENDOR_DIR/..."
        MANIFEST="$REPO_ROOT/$VENDOR_DIR/MANIFEST.json"
        errors=0
        if [[ -f "$MANIFEST" ]] && command -v jq &> /dev/null; then
            while IFS='|' read -r filename sha256; do
                full_path="$REPO_ROOT/$VENDOR_DIR/$filename"
                if [[ -f "$full_path" ]]; then
                    actual_sha256=$(sha256sum "$full_path" | cut -d' ' -f1)
                    if [[ "$actual_sha256" == "$sha256" ]]; then
                        echo "  OK: $filename"
                    else
                        echo "  MISMATCH: $filename"
                        echo "    Expected: $sha256"
                        echo "    Actual:   $actual_sha256"
                        ((errors++)) || true
                    fi
                else
                    echo "  MISSING: $filename"
                    ((errors++)) || true
                fi
            done < <(jq -r '.sources[] | "\(.filename)|\(.sha256)"' "$MANIFEST" 2>/dev/null)

            if [[ $errors -eq 0 ]]; then
                echo "All vendored sources verified successfully."
            else
                echo "Verification failed: $errors error(s)"
                exit 1
            fi
        else
            echo "  No manifest found at $MANIFEST"
        fi
        ;;

    download)
        echo "Vendoring $SOURCES_COUNT source(s) to $VENDOR_DIR/..."
        DEST_DIR="$ROOT/$VENDOR_DIR"
        MANIFEST="$DEST_DIR/MANIFEST.json"

        # Create vendor directory
        mkdir -p "$DEST_DIR"

        # Initialize manifest if it doesn't exist
        if [[ ! -f "$MANIFEST" ]]; then
            echo '{"version": 1, "sources": []}' > "$MANIFEST"
        fi

        # Process each source
        for ((i=0; i<SOURCES_COUNT; i++)); do
            eval "TARGET=\$SOURCE_${i}_TARGET"
            eval "SRC_URI=\$SOURCE_${i}_SRC_URI"
            eval "SHA256=\$SOURCE_${i}_SHA256"
            eval "FILENAME=\$SOURCE_${i}_FILENAME"
            eval "SIG_SHA256=\$SOURCE_${i}_SIG_SHA256"

            DEST_FILE="$DEST_DIR/$FILENAME"

            # Check if already vendored with correct checksum
            if [[ -f "$DEST_FILE" ]]; then
                actual_sha256=$(sha256sum "$DEST_FILE" | cut -d' ' -f1)
                if [[ "$actual_sha256" == "$SHA256" ]]; then
                    echo "  Already vendored: $FILENAME"
                    continue
                else
                    echo "  Checksum mismatch, re-downloading: $FILENAME"
                fi
            fi

            echo "  Downloading: $SRC_URI"
            echo "           -> $VENDOR_DIR/$FILENAME"

            # Download the file
            if curl -fsSL --retry 3 --retry-delay 2 -o "$DEST_FILE" "$SRC_URI"; then
                # Verify checksum
                actual_sha256=$(sha256sum "$DEST_FILE" | cut -d' ' -f1)
                if [[ "$actual_sha256" != "$SHA256" ]]; then
                    echo "    ERROR: SHA256 mismatch!"
                    echo "      Expected: $SHA256"
                    echo "      Actual:   $actual_sha256"
                    rm -f "$DEST_FILE"
                    continue
                fi
                echo "    SHA256 verified: $actual_sha256"

                # Download signature if available
                if [[ -n "$SIG_SHA256" ]]; then
                    SIG_FILE="$DEST_FILE.sig"
                    for ext in .sig .asc .sign; do
                        if curl -fsSL --retry 3 --retry-delay 2 -o "$SIG_FILE" "${SRC_URI}${ext}" 2>/dev/null; then
                            sig_actual=$(sha256sum "$SIG_FILE" | cut -d' ' -f1)
                            if [[ "$sig_actual" == "$SIG_SHA256" ]]; then
                                echo "    Signature downloaded: ${FILENAME}${ext}"
                                break
                            fi
                            rm -f "$SIG_FILE"
                        fi
                    done
                fi

                # Update manifest
                if command -v jq &> /dev/null; then
                    # Remove existing entry for this target if present
                    tmp_manifest=$(mktemp)
                    jq --arg target "$TARGET" 'del(.sources[] | select(.target == $target))' "$MANIFEST" > "$tmp_manifest"

                    # Add new entry
                    new_entry=$(jq -n \
                        --arg target "$TARGET" \
                        --arg src_uri "$SRC_URI" \
                        --arg sha256 "$SHA256" \
                        --arg filename "$FILENAME" \
                        --arg sig_sha256 "${SIG_SHA256:-}" \
                        --arg vendored_at "$(date -Iseconds)" \
                        '{
                            target: $target,
                            src_uri: $src_uri,
                            sha256: $sha256,
                            filename: $filename,
                            signature_sha256: (if $sig_sha256 == "" then null else $sig_sha256 end),
                            vendored_at: $vendored_at
                        }')

                    jq --argjson entry "$new_entry" '.sources += [$entry]' "$tmp_manifest" > "$MANIFEST"
                    rm -f "$tmp_manifest"
                fi
            else
                echo "    ERROR: Failed to download $SRC_URI"
            fi
        done

        echo "Done."
        ;;

    *)
        # No action specified, just print BXL output (dry-run or error)
        echo "$BXL_OUTPUT"
        ;;
esac
